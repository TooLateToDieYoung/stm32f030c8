## The process of initializing the TIM
```C
// ! The timer is too complicated to record in one page

// ? See the different cases at the bottom ( C language example )

// ? The following is the basic process of selecting TIM1 to display
```

1. Enable the peripheral clock on TIM
    ```C
    // ? Query RCC to learn more about clocks

    RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;
    ```

2. Configure the counter mode
    ```C 
    // ! only for TIM1, TIM2, TIM3

    TIM1->CR1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
    TIM1->CR1 |= ??? ;
    ```

3. Configure the clock division
    ```C
    // ? expect TIM6 ( stm32f030c8 without TIM6 )

    TIM1->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
    TIM1->CR1 |= ??? ;
    ```

4. Configure the Autoreload value
    ```C
    TIM1->ARR = ??? ;
    ```

5. Configure the Prescaler value
    ```C
    TIM1->PSC = ??? ;
    ```

6. Configure the Repetition Counter value
    ```C
    // ! only for TIM1, TIM15, TIM16, TIM17 ( stm32f030c8 without TIM15 )

    TIM1->RCR = ??? ;
    ```

7. Generate an update event
    ```C
    // Reload the Prescaler and the Repetition counter values immediately
    TIM1->EGR |= TIM_PSCReloadMode_Immediate;
    ```

8. Open TIMx when needed
    ```C
    TIM1->CR1 |= TIM_CR_CEN;
    ```


---
## Description of TIMx

1. stm32f030c8 offers
    - 1 Advanced-control timers ( TIM1 )
    - 5 General-purpose timer ( TIM2, TIM3, TIM14, TIM16, TIM17 )
      - 4 channels : TIM2, TIM3
      - 1 channel  : TIM14
      - 2 channels : TIM16, TIM17

---
## Description of TIMx registers

1. TIMx control register 1 (TIMx->CR1) 16bits

    * Clock division : CKD[1:0]
      ```C
      // ! function unknown, always write 0
      ```

    * Auto-reload preload enable : ARPE
      - 0 -> TIMx->ARR register is not buffered
      - 1 -> TIMx->ARR register is buffered

    * Center-aligned mode selection : CMS[1:0]
      ```C
      // ! it is not allowed to switch as long as CEN = 1
      /*
      ? CMS[1:0] is only meaningful in output compare mode

      If satisfy the following
        | 1. ( CCxS[1:0] == 00 ) in TIMx->CCMRx 
        | 2. ( CMS[1:0]  != 00 ) in TIMx->CR1
        -> then The counter counts up and down alternatively.
        -> Output compare interrupt flags of channels configured
            are set according to CMS[1:0] in TIMx->CR1.
      */
      ```
      - 00 -> Edge-aligned mode.
        ```C
        // ? The counter counts up or down 
        // -> depending on the direction bit ( DIR )
        ```
      - 01 -> Center-aligned mode 1.
        ```C
        // set only when the counter is counting down
        ```
      - 10 -> Center-aligned mode 2.
        ```C
        // set only when the counter is counting up
        ```
      - 11 -> Center-aligned mode 3.
        ```C
        // set only when the counter is counting up or down
        ```

    * Direction : DIR
      - 0 -> Counter used as upcounter
      - 1 -> Counter used as downcounter

    * One pulse mode : OPM
      - 0 -> Counter is not stopped at update event
      - 1 -> Counter stops counting at the next update event ( also clearing the bit CEN )

    * Update request source : URS
      ```C
      // ? This bit determines the UEV event sources
      // -> determine how to generate update interrupts or DMA requests
      ```
      - 0 -> Any of the following events generate update request
        ```C
        /* 
        These events can be:
          | 1. Counter overflow/underflow
          | 2. Setting the UG bit
          | 3. Update generation through the slave mode controller
        */
        ```
      - 1 -> Only counter overflow/underflow can generates it

    * Update disable : UDIS
      ```C
      // ? This bit determines to enable/disable UEV event generation
      // -> determine how to generate update interrupts or DMA requests
      ```
      - 0 -> UEV enabled
        ```C
        // The Update event is generated by one of the following events:
        // @ Counter overflow/underflow
        // @ Setting the UG bit
        // @ Update generation through the slave mode controller
        // Buffered registers are then loaded with their preload values
        ```
      - 1 -> UEV disabled.
    
    * Counter enable : CEN
      - 0 -> Counter disabled
      - 1 -> Counter enabled

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|x|x|x|x|x|x|CKD[1:0]||APPE|CMS[1:0]||DIR|OPM|URS|UDIS|CEN|

---

2. TIMx control register 2 ( TIMx->CR2 ) 16bits
    ```C
    // ! function unknown, always save old value
    ```

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|x|OIS4|OIS3N|OIS3|OIS2N|OIS2|OIS1N|OIS1|TI1S|MMS[2:0]|||CCDS|CCUS|x|CCPC|

---

3. TIMx DMA/interrupt enable register ( TIMx->DIER ) 16bits

    * Update DMA request enable : UDE
      - 0 -> Update DMA request disabled
      - 1 -> Update DMA request enabled

    * Update interrupt enable : UIE 
      - 0 -> Update interrupt disabled
      - 1 -> Update interrupt enabled

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|x|TDE|COMDE|CC4DE|CC3DE|CC2DE|CC1DE|UDE|BIE|TIE|COMIE|CC4IE|CC3IE|CC2IE|CC1IE|UIE|

---

4. TIMx status register ( TIMx->SR ) 16bits

    * Update interrupt flag : UIF
      ! how it works unknown
      - 0 -> No update occurred
      - 1 -> Update interrupt pending

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|x|x|x|CC4DF|CC3DF|CC2DF|CC1DF|x|BIF|TIF|COMIF|CC4IF|CC3IF|CC2IF|CC1IF|UIF|

---
5. TIMx event generation register ( TIMx->EGR )

    * Update generation : UG
      ```C
      // ? This bit can be set by software
      // ? It is automatically cleared by hardware
      ```
      - 0 -> No action
      - 1 -> Reinitialize the counter and generates an update of the registers
        ```C
          // ? if DIR == 0 (upcounting),   CNT become 0
          // ? if DIR == 1 (downcounting), CNT become TIMx->ARR
        ```

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|x|x|x|x|x|x|x|x|BG|TG|COMG|CC4G|CC3G|CC2G|CC1G|UG|

---
6. TIMx capture/compare mode register x ( TIMx->CCMRx ) 16bits
    * -- $Channel\ mode\ selection$ ------------------

      * Capture/Compare x Selection : CCxS[1:0]
          ```C
          // CCxS[1:0] decides TIMx to input capture / output compare
          ```
          - 00 -> CCx channel is configured as output
          - 01 -> CCx channel is configured as input, ICx is mapped on TI1
          - 10 -> CCx channel is configured as input, ICx is mapped on TI2
          - 11 -> CCx channel is configured as input, ICx is mapped on TRC
              ```C
              // This mode ( CCxS == 11 ) is working 
              // only if an internal trigger input is selected
              // through TS bit ( TS in TIMx->SMCR )
              ```

    * -- $Input\ Capture\ mode$ ----------------------
  
      * Input capture x filter : ICxF[3:0]
        ```C
        // ! function unknown
        ```
      * Input capture x prescaler : ICxPSC[1:0]
        ```C
        // ! function unknown
        ```

    * -- $Output\ Compare\ mode$ --------------------

      * Output Compare x clear enable : OCxCE
        ```C
        // ! function unknown
        ```

      * Output Compare x mode : OCxM[2:0]
          - 000 -> Frozen - Ignore TIMx->CR1 and TIMx->CNT
          - 001 -> Set channel x to active level on match
            ```C
            // OC1REF is high when TIMx->CNT matches TIMx->CCR1
            ```
          - 010 -> Set channel x to inactive level on match
            ```C
            // OC1REF is low when TIMx->CNT matches TIMx->CCR1
            ```
          - 011 -> Toggle - OC1REF toggles when TIMx->CNT == TIMx->CCR1
          - 100 -> Force inactive level - OC1REF is forced low
          - 101 -> Force active level - OC1REF is forced high
          - 110 -> PWM mode 1
            ```C
            // channel x is active as long as TIMx->CNT < TIMx->CCR1 
            ```
          - 111 -> PWM mode 2             
            ```C
            // channel x is active as long as TIMx->CNT > TIMx->CCR1 
            ```

      * Output Compare x preload enable : OCxPE
          - 0: Preload register on TIMx->CCR1 disabled.
            ```C
            // TIMx_CCR1 can be written at anytime
            // -> The new value is taken in account immediately
            ```
          - 1: Preload register on TIMx->CCR1 enabled.
            ```C
            // Read/Write operations access the preload register
            // TIMx->CCR1 preload value is loaded in the active register at each update event
            ```

      * Output Compare 2 fast enable : OCxFE
        ```C
        // Output Compare fast mode acts 
        // only if the channel is configured in PWM1 or PWM2 mode
        ```

-- $Input\ Capture\ mode$ ----------------------

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|ICxF[3:0]||||ICxPSC[1:0]||CCxS[1:0]||ICxF[3:0]||||ICxPSC[1:0]||CCxS[1:0]||

-- $Output\ Compare\ mode$ ---------------------

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|OCxCE|OCxM[2:0]|||OCxPE|OCxFE|CCxS[1:0]||OCxCE|OCxM[2:0]|||OCxPE|OCxFE|CCxS[1:0]||

---
7. TIMx capture/compare enable register ( TIMx->CCER ) 16bits

    * Capture/Compare x complementary output polarity : CCxNP
      -- $Output\ Compare\ mode$ ---------------------
        - 0 -> OC1N active high
        - 1 -> OC1N active low
     
      -- $Input\ Capture\ mode$ ----------------------
      ```C
      // ! function unknown
      ```

    * Capture/Compare x complementary output enable : CCxNE
      - 0 -> Off - OC1N is not active.
      - 1 -> On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.

    * Capture/Compare x output polarity : CC1P
      -- $Output\ Compare\ mode$ ---------------------
      - 0 -> OC1 active high
      - 1 -> OC1 active low

      -- $Input\ Capture\ mode$ ----------------------
      ```C
      // ! function unknown
      ```

    * Capture/Compare x output enable : CCxE
      -- $Output\ Compare\ mode$ ---------------------
      - 0 -> Off - OC1 is not active
      - 1 -> On - OC1 signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits

      -- $Input\ Capture\ mode$ ----------------------
      This bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (TIMx->CCR1) or not
      - 0 -> Capture disabled
      - 1 -> Capture enabled

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|CC4NP|CC4NE|CC4P|CC4E|CC3NP|CC3NE|CC3P|CC3E|CC2NP|CC2NE|CC2P|CC2E|CC1NP|CC1NE|CC1P|CC1E|

---

8. TIMx counter ( TIMx->CNT ) 16bits

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|CNT[15:0]||||||||||||||||

---

9. TIMx prescaler ( TIMx->PSC ) 16bits
    ```C
    // ? The counter clock frequency (CK_CNT) 
    // ? is equal to fCK_PSC / (PSC[15:0] + 1).
    ```

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|PSC[15:0]||||||||||||||||

---

10. TIMx auto-reload register ( TIMx->ARR ) 16bits
    ```C
    // ! The counter is blocked while the auto-reload value is null
    ```

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|ARR[15:0]||||||||||||||||

---

11. TIMx repetition counter register (TIMx->RCR) 16bits

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|x|x|x|x|x|x|x|x|REP[7:0]||||||||

---

12. TIMx capture/compare register x (TIMx->CCRx) 16bits

    * -- $Output\ Compare\ mode$ ---------------------`
      ```C
      /*
      CCRx is the value to be loaded in the actual capture/compare 1 register (preload value).

      It is loaded permanently if the preload feature is not selected in the TIMx->CCMRx register (bit OCxPE).

      Else the preload value is copied in the active capture/compare x register when an update event occurs.

      The active capture/compare register contains the value to be compared to the counter TIMx->CNT and signaled on OCx output.
      */
      ```

    * -- $Input\ Capture\ mode$ ----------------------
      ```C
      // ? CCR1 is the counter value transferred by
      // ? the last input capture x event (ICx).
      ```

-tx-
|B15|B14|B13|B12|B11|B10|B9|B8|B7|B6|B5|B4|B3|B2|B1|B0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|CCRx[15:0]||||||||||||||||

---

## C language example

1. pure counter mode
```C
// Using TIM3 to be counter, period time = 4us 
void Init_Configure(void)
{
  // clock : SYSCLK 48MHz -> AHB 48MHz -> APB1 48MHz -> TIM3 48MHz
  RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

  TIM3->CR1 &= (uint16_t)(~((uint16_t)(
      TIM_CR1_DIR | // Counter used as upcounter
      TIM_CR1_CMS | // Edge-aligned mode
      TIM_CR1_CKD | // Clock division = 0
      TIM_CR1_OPM | // Counter is not stopped at update event
      TIM_CR1_URS | // Multiple update event trigger options
      TIM_CR1_UDIS  // UEV enabled
    )));

  // let TIM3->ARR register be buffered
  TIM3->CR1 |= TIM_CR1_ARRE; 

  // TIM3_CLK / ( TIM3->PSC + 1 ) = 48MHz / 4 = 12MHz
  // TIM3->CNT counts 1 time per ( 1 / 12MHz ) seconds
  TIM3->PSC = (uint16_t)( 4 - 1 );

  // The period of TIM3->CNT is ( TIM3->ARR + 1 ) = 48 counts
  // One period is 48 * ( 1 / 12MHz ) seconds = 4us
  TIM3->ARR = 48 - 1;

  // Generate an update event to reload 
  // the Prescaler and the Repetition counter values immediately
  TIM3->EGR = TIM_PSCReloadMode_Immediate; // is same as TIM_EGR_UG;

  /* open it
    TIM3->SR = 0; // clear status before starting to count
    TIM3->CR1 |= TIM_CR1_CEN; // Go
  */

  /* close it
    TIM3->CR1 &= ~((uint16_t)TIM_CR1_CEN);
  */
}
```

---

2. output compare mode
```C
#define TIM1_CH1 GPIO_Pin_8

// Using TIM1 with channel 1 / 1N to PWM2 output
void Init_Configure(void)
{
  // open GPIOA clock
  RCC->AHBENR |= RCC_AHBENR_GPIOAEN;

  // set speed of pin = 50MHz
  GPIOA->OSPEEDR |= ( (uint32_t)3 << ( TIM1_CH1 * 2 ) );

  // Output push-pull ( PP )
  GPIOx->OTYPER &= ~((uint16_t)TIM1_CH1);
  
  // reset to AF
  GPIOx->MODER  &= ~( (uint32_t)3 << ( TIM1_CH1 * 2 ) );
	GPIOA->MODER |= ( (uint32_t)2 << ( TIM1_CH1 * 2 ) );

  // Pull-up
  GPIOx->PUPDR &= ~( (uint32_t)3 << ( TIM1_CH1 * 2 ) );
  GPIOx->PUPDR |= ( (uint32_t)1 << ( TIM1_CH1 * 2 ) );

  // GPIOx->AFRH for pin 8 -> set AF2 for TIM1_CH1
  GPIOA->AFR[1] &= ~((uint32_t)15);
  GPIOA->AFR[1] |= ~((uint32_t)2);

/* TIM1 */
  // clock : SYSCLK 48MHz -> AHB 48MHz -> APB2 48MHz -> TIM1 48MHz
  RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;

  TIM1->CR1 &= (uint16_t)(~((uint16_t)(
      TIM_CR1_DIR  | // Counter used as upcounter
      TIM_CR1_CMS  | // Edge-aligned mode
      TIM_CR1_ARRE | // disable auto reload register to be buffered
      TIM_CR1_CKD  | // Clock division = 0
      TIM_CR1_OPM  | // Counter is not stopped at update event
      TIM_CR1_URS  | // Multiple update event trigger options
      TIM_CR1_UDIS   // UEV enabled
    )));

  // TIM1_CLK / ( TIM3->PSC + 1 ) = 48MHz / 1 = 48MHz
  // TIM1->CNT counts 1 time per ( 1 / 48MHz ) seconds
  TIM1->PSC = (uint16_t)( 1 - 1 );

  // The period of TIM3->CNT is ( TIM3->ARR + 1 ) = 256 counts
  // One period is 256 * ( 1 / 48MHz ) seconds = 5.333us
  TIM1->ARR = (uint16_t)( 256 - 1 );

  // Set the Repetition Counter value
  TIM1->RCR = 0; // just for TIM1, TIM15, TIM16, TIM17

  // Generate an update event to reload 
  // the Prescaler and the Repetition counter values immediately
  TIM3->EGR = TIM_PSCReloadMode_Immediate; // is same as TIM_EGR_UG;

/* channel 1 output compare setup */
// begin ---------------------------------------------
  // Disable the Channel 1
  TIM1->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
  
  // Set it output mode
  TIM1->CCMR1 &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));

  // Reset the Output Compare Mode Bits to PWM2
  TIM1->CCMR1 &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
  TIM1->CCMR1 |= TIM_OCMode_PWM2; // channel 1 is active as long as TIM1->CNT > TIM1->CCR1
  
  TIM1->CCER |= (uint16_t)(
      TIM_CCER_CC1P | // Reset the Output Polarity level -> active is high
      TIM_CCER_CC1E   // Open the channel 1
    );

  // Reset the channel 1 Ouput Compare IDLE high
  TIM1->CR2 |= (uint16_t)(TIM_CR2_OIS1);
// ----------------------------------------------- end

/* channel 1N output compare setup */
/* the following just for TIM1, TIM15, TIM16, TIM17 */
// begin ---------------------------------------------
  // disable channel 1 output N
  TIM1->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));

  // Reset the Output N Polarity level -> active is low
  TIM1->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
  
  // enable channel 1 output N
  TIM1->CCER |= (uint16_t)(TIM_CCER_CC1NE);
  
  // Reset the Ouput Compare and Output Compare N IDLE State
  TIM1->CR2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N)); // IDLE low

  // Compute CCR1 value to generate a duty cycle at 40% for channel 2 and 2N
  TIM1->CCR1 = (uint16_t) (((uint32_t) 40 * ( TIM1->ARR - 1 )) / 100); 
// ----------------------------------------------- end

  /* open it
    TIM1->SR = 0; // clear status before starting to count
    TIM1->CR1  |= TIM_CR1_CEN;  // Go
    TIM1->BDTR |= TIM_BDTR_MOE; // release the channel 1 / 1N for PWM output
  */

  /* close it
    TIM1->CR1 &= ~((uint16_t)TIM_CR1_CEN);
    TIM1->BDTR &= ~((uint16_t)TIM_BDTR_MOE); // force channel 1 / 1N to IDLE
  */
}
```